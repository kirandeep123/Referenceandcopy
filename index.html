<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>JS Reference VS Copy</title>
</head>

<body>

    <script>
        // start with strings, numbers and booleans

        let num = 10;
        num2 = num;
        console.log(num, num2);
        num = 20;
        console.log(num, num2);


        let string = 'kiran';
        string2 = string;

        console.log(string, string2);
        string = 'deep';
        console.log(string, string2);

        let booleaan = true;
        boolean2 = booleaan;
        console.log(booleaan, boolean2);
        booleaan = false;
        console.log(booleaan, boolean2);
        //  console.log(num ,num2);
        // Let's say we have an array
        const players = ['Wes', 'Sarah', 'Ryan', 'Poppy']; //original array 
        players2 = players;
        //  console.log(players,players2);
        players2[2] = "deep";
        //  console.log(players,players2);

        // oh no - we have edited the original array too!

        // Why? It's because that is an array reference, not an array copy. They both point to the same array!

        // So, how do we fix this? We take a copy instead!

        // one way to copy the array and not refering to its reference is use slice 

        const players3 = players.slice();
        // console.log(players,players3);
        players3[2] = 'kaur';
        //console.log(players,players3);

        // or create a new array and concat the old one in

        const players4 = [].concat(players);
        //   console.log(players,players4);
        players4[2] = "bla bla bla";
        //   console.log(players,players4);
        // or use the new ES6 Spread


        const players5 = [...players];
        console.log(players, players5);
        players5[2] = "okay ";
        console.log(players, players5);


        // anoher way to copy array is use Array.from

        const players6 = Array.from(players);

        // now when we update it, the original one isn't changed

        // The same thing goes for objects, let's say we have a person object

        // with Objects

        const person = {
            name: 'kiran',
            age: 25
        }
        const person2 = person;
        // and think we make a copy:
        console.clear();

        // how do we take a copy instead?

        const person3 = Object.assign({}, person, {
            numberssss: 33
        });

        const newObjectArray = {
            name: 'kiran',
            age: 33,
            study: {
                matriculation: "pass",
                Bachelors: "pass"
            }
        };

        const array2 = Object.assign({}, newObjectArray);

        //assign works only on first level i.e. it doesnot work with deep level /nested level .it will change the original array if oyu change data of copied object ..

        //so use deep cloning instead of assign 

        //JSON.stringify :- change object to string 
        //JSON.parse : change string to oject .

        const team = JSON.parse(JSON.stringify(newObjectArray));

        // We will hopefully soon see the object ...spread

        // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
    </script>

</body>

</html>